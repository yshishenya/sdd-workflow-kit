# SDD in This Repo (Spec Kit + sdd-kit overlay)

> Tooling: `sdd-workflow-kit {{kit_version}}`

This repository uses Spec-Driven Development (SDD) in a hybrid mode:

- **SDD core**: GitHub **Spec Kit** (markdown pipeline `spec.md → plan.md → tasks.md → implement`)
- **Overlay**: `sdd-kit` (installs/pins infrastructure, drift-checks managed files, optional scaffolds)

## TL;DR

### For developers (daily loop)

1. Create a feature: `speckit.specify` (or `.specify/scripts/.../create-new-feature.*`)
2. Plan: `speckit.plan`
3. Tasks: `speckit.tasks`
4. Implement: `speckit.implement`
5. Before PR: `python3 .tooling/sdd-workflow-kit/bin/sdd-kit check --project .`

### For repo admins (setup + updates)

1. Pull submodules: `git submodule update --init --recursive`
2. Sync managed files: `python3 .tooling/sdd-workflow-kit/bin/sdd-kit sync --project .`
3. Drift gate: `python3 .tooling/sdd-workflow-kit/bin/sdd-kit check --project .`
4. Toolchain updates: bump `.tooling/sdd-workflow-kit` to a new tag, then `sync` + `check`

## What This Is (and Why)

Goal: make the workflow reproducible.

- Spec Kit defines the **single SDD loop** for new features.
- `sdd-kit` makes the Spec Kit infrastructure **pinned** and **drift-checkable**.

We intentionally do not “own the whole repo”. Only selected managed files are enforced.

## How It Works (Diagram)

```mermaid
flowchart LR
  KIT["sdd-workflow-kit (git submodule)"] --> SYNC["sdd-kit sync"]
  SYNC --> SPECIFY[".specify/* (Spec Kit scripts + templates)"]
  SYNC --> PROMPTS[".codex/prompts/speckit.*.md"]
  SYNC --> FRAG[".sddkit/fragments/AGENTS.manual.md"]

  DEV["Developer / agent"] --> SPK["speckit.specify/plan/tasks/implement"]
  SPK --> SPECIFY
  SPK --> SPECS["specs/###-feature/{spec,plan,tasks}.md"]

  SPECIFY --> AG["AGENTS.md (Spec Kit updater)"]
  FRAG --> AG

  CHECK["sdd-kit check (CI/local gate)"] --> SPECIFY
  CHECK --> PROMPTS
  CHECK --> AG
```

## Where Things Live (Layout)

```text
.sddkit/
  config.toml                  # sdd-kit config (manual)
  fragments/
    AGENTS.manual.md           # overlay for AGENTS.md MANUAL block (edit this)

.specify/                      # managed: Spec Kit templates/scripts (installed by sdd-kit)
  templates/
  scripts/
    bash/                      # sh scripts (mac/linux)
    powershell/                # ps scripts (windows)
  memory/
    constitution.md            # created if missing; user-editable
  THIRD_PARTY_NOTICES.md       # managed: upstream Spec Kit attribution

.codex/prompts/                # managed: Codex commands (speckit.*)
  speckit.specify.md
  speckit.plan.md
  speckit.tasks.md
  speckit.implement.md

specs/                         # NOT managed: per-feature artifacts (created by Spec Kit)
  001-feature-name/
    spec.md
    plan.md
    tasks.md
```

## Ownership and Drift Check Rules

- `.specify/templates/*`: managed by `sdd-kit` (copied from pinned Spec Kit). Drift-checked.
- `.specify/scripts/*`: managed by `sdd-kit`. Drift-checked.
- `.codex/prompts/speckit.*.md`: managed by `sdd-kit` (generated from pinned Spec Kit). Drift-checked.
- `.specify/memory/constitution.md`: yours. `sdd-kit` only creates it if missing.
- `specs/**`: feature artifacts. Not drift-checked.
- `AGENTS.md`: updated by Spec Kit (`update-agent-context.*`). `sdd-kit` only patches the MANUAL block.

### Important: `AGENTS.md`

`AGENTS.md` is the agent context file (commands, repo map, constraints).

In Spec Kit mode, `sdd-kit` does not generate it end-to-end. It is created/updated by the Spec Kit script `update-agent-context` (usually during `speckit.plan`).

To generate/update `AGENTS.md` manually (if needed):

```bash
bash .specify/scripts/bash/update-agent-context.sh codex
```

Put local additions into:

- `.sddkit/fragments/AGENTS.manual.md`

After changing the fragment, apply the overlay:

```bash
python3 .tooling/sdd-workflow-kit/bin/sdd-kit sync --project .
```

`sync` patches only:

```text
<!-- MANUAL ADDITIONS START -->
...
<!-- MANUAL ADDITIONS END -->
```

This prevents “two tools fighting over the same file”.

Important: do not edit `AGENTS.md` directly. In Spec Kit mode, `sdd-kit check` validates that the MANUAL block matches `.sddkit/fragments/AGENTS.manual.md`.

## Developer Workflow (Step by Step)

### SDD loop (diagram)

```mermaid
flowchart TD
  START["Start"] --> SPECIFY["speckit.specify"]
  SPECIFY --> SPEC["specs/###-.../spec.md"]

  SPEC --> AMBIG{"Ambiguity?"}
  AMBIG -->|yes| CLARIFY["speckit.clarify"] --> SPEC

  AMBIG -->|no| PLAN["speckit.plan"]
  PLAN --> PLAN_OUT["plan.md + artifacts + AGENTS.md"]
  PLAN_OUT --> TASKS["speckit.tasks"]
  TASKS --> TASKS_MD["tasks.md"]

  TASKS_MD --> ANALYZE_OK{"Need analysis?"}
  ANALYZE_OK -->|yes| ANALYZE["speckit.analyze (read-only)"] --> TASKS_MD
  ANALYZE_OK -->|no| IMPLEMENT["speckit.implement"]
  IMPLEMENT --> CODE["Code + tests"]

  CODE --> DRIFT["sdd-kit check"]
  DRIFT --> PR["PR"]
```

### 0) After `git clone`

If the repo uses submodules:

```bash
git submodule update --init --recursive
```

### 1) `speckit.specify` (create `spec.md`)

Why: start a new feature and produce a strong `spec.md` (what/why), without implementation details.

How to run (agent):

- `speckit.specify <1-3 sentences describing the feature>`

Example:

- `speckit.specify Add PDF export for admin reports`

Script-only (no agent, mac/linux):

```bash
bash .specify/scripts/bash/create-new-feature.sh "Short feature description"
```

What it does / outputs:

- creates and checks out a branch like `001-feature-name`
- creates `specs/001-feature-name/`
- writes `specs/001-feature-name/spec.md` using the template
- often creates `specs/001-feature-name/checklists/requirements.md` (requirements-quality checklist)

### 1.1) (Optional) `speckit.clarify` (remove ambiguity in `spec.md`)

Why: clarify the spec before planning. It asks a small number of targeted questions (up to 5) and writes answers back into `spec.md`.

How to run:

- `speckit.clarify`

Result:

- updates the current `specs/001-.../spec.md` (adds a Clarifications section and tightens requirements)

### 2) `speckit.plan` (create `plan.md` + design artifacts)

Why: turn `spec.md` into a technical plan and the artifacts needed for task breakdown.

Prerequisites:

- you are on the `001-...` feature branch (usually created by `speckit.specify`)
- `specs/001-.../spec.md` exists

How to run (agent):

- `speckit.plan` (optionally add context: stack/platform/constraints)

Script-only:

```bash
bash .specify/scripts/bash/setup-plan.sh
bash .specify/scripts/bash/update-agent-context.sh codex
```

What it does / outputs:

- creates/updates `specs/001-.../plan.md`
- usually creates extra files in `specs/001-.../` (varies by project)
- updates `AGENTS.md` via `update-agent-context` (the MANUAL overlay block is preserved)

Common planning artifacts (if applicable):

- `specs/001-.../research.md`
- `specs/001-.../data-model.md`
- `specs/001-.../contracts/*`
- `specs/001-.../quickstart.md`

### 3) `speckit.tasks` (generate `tasks.md`)

Why: produce an executable `tasks.md` (IDs, dependencies, and file paths) you can implement step by step.

How to run:

- `speckit.tasks`

What it does:

- reads `spec.md` and `plan.md` (and optional artifacts, if present)
- generates `specs/001-.../tasks.md` using the template
- uses checkbox tasks like `- [ ] T001 ... path/to/file` and groups tasks by user story

Practice:

- if you update `plan.md` or requirements, regenerate `tasks.md` (expected)
- for a read-only consistency gate before implementation: `speckit.analyze`

### 4) `speckit.implement` (execute `tasks.md`)

Why: implement tasks while preserving traceability "spec -> plan -> tasks -> code".

How to run:

- `speckit.implement`

What it does:

- reads `tasks.md`/`plan.md` (and optional artifacts)
- executes tasks in phases and marks completed items as `[X]` in `tasks.md`
- may stop and ask for confirmation if checklists under `specs/001-.../checklists/` are incomplete

Rules of thumb:

- Do one task at a time.
- Run real checks (tests/lint/build) frequently.
- If requirements change: update `spec.md/plan.md/tasks.md` before continuing.

### Extra `speckit.*` commands (when needed)

- `speckit.analyze`: read-only cross-artifact consistency report (`spec.md`/`plan.md`/`tasks.md`).
- `speckit.checklist <topic>`: creates a requirements-quality checklist under `specs/001-.../checklists/*.md` (not code tests).
- `speckit.planreview`: multi-model review of `spec.md/plan.md/tasks.md` (advisory-only) and writes a report to `specs/001-.../reviews/planreview.md`. Typically run after `speckit.plan` and before `speckit.tasks/implement`. Requires `opencode` installed (and optionally other tools).
- `speckit.constitution`: create/update `.specify/memory/constitution.md`. In this hybrid mode, do not manually edit `.specify/templates/*` or `.codex/prompts/*` (managed by `sdd-kit`).
- `speckit.taskstoissues`: turns tasks into GitHub issues (requires a GitHub remote + GitHub MCP configured for the agent).

### 5) Before PR: drift-check

```bash
python3 .tooling/sdd-workflow-kit/bin/sdd-kit check --project .
```

If you see `DRIFT/MISSING`:

```bash
python3 .tooling/sdd-workflow-kit/bin/sdd-kit sync --project .
python3 .tooling/sdd-workflow-kit/bin/sdd-kit check --project .
```

## Admin Guide

### Core commands

- `bootstrap`: create `.sddkit/config.toml` (if missing) and run `sync`
- `sync`: install/update managed files
- `check`: drift gate (CI)

### Safe mode

By default `safe_mode = true`.

- `sdd-kit` only edits files it previously marked as managed.
- If a file already exists but is not managed, it is skipped and reported as `UNMANAGED`.

### CI drift gate (GitHub Actions)

Critical in Spec Kit mode: checkout with `submodules: recursive`.

Typical CI command:

```bash
python3 .tooling/sdd-workflow-kit/bin/sdd-kit check --project . --config .sddkit/config.toml
```

### Updating `sdd-workflow-kit` in this repo

Recommended process:

1. Update the `.tooling/sdd-workflow-kit` submodule to a new tag.
2. `git submodule update --init --recursive`
3. `sync` and `check`
4. Commit: the submodule bump + updated managed files.

### Upstream sync (if this repo is a fork)

If this repository is a fork and you periodically integrate upstream changes, do it as a separate workflow to minimize conflicts.

1) Add an `upstream` remote once:

```bash
git remote add upstream <UPSTREAM_GIT_URL>
git fetch upstream --tags
```

2) Sync on a dedicated branch:

```bash
git checkout <integration-branch>
git pull
git checkout -b chore/upstream-sync-YYYY-MM-DD
```

3) Integrate upstream (choose one approach per your team policy):

- merge:

```bash
git merge upstream/<branch>
```

- rebase:

```bash
git rebase upstream/<branch>
```

4) Resolve conflicts, run checks, and commit the result.

### Memory Bank (optional)

Memory Bank can be enabled alongside Spec Kit.

Does it work automatically? No. The kit installs and updates managed scaffolds on `sdd-kit sync`, but the content is maintained by humans (or the agent). There are no background processes.

Default location: `meta/memory_bank/`.

How to use (minimum):

1) Before any task, open `meta/memory_bank/README.md` and follow the Mandatory Reading Sequence.
2) If you add a dependency or change architecture, update `meta/memory_bank/tech_stack.md` and/or the relevant `patterns/*`.
3) For tracking work:

- on feature branches, do not edit `meta/memory_bank/current_tasks.md`
- write updates into `meta/memory_bank/branch_updates/*.md`
- on the integration branch, copy updates into `current_tasks.md` and delete processed update files

Helper: `meta/tools/merge_task_updates.sh` lists pending branch updates.

In `.sddkit/config.toml`:

```toml
[manage]
memory_bank = true
meta_tools = true
meta_sdd = true
```

Then:

```bash
python3 .tooling/sdd-workflow-kit/bin/sdd-kit sync --project .
```

### Human-readable specifications

- In Spec Kit mode, your specs/plans/tasks are already human-readable Markdown: `specs/###-.../{spec,plan,tasks}.md`.
- If you use JSON SDD (optional, `meta/sdd/specs/*.json`), you can render Markdown for review/sharing using your `sdd` CLI:

```bash
meta/tools/sdd render --help
```

Then render to a file (flags depend on your `sdd` CLI). Recommendation: keep rendered output next to the JSON specs (for example `meta/sdd/rendered/*.md`) or publish it as a CI artifact.

## Troubleshooting

### `UNMANAGED ... (safe_mode)`

The file already exists and is not managed.

Options:

- rename/remove it, then run `sync` again
- disable managing that area in `[manage]`

### Spec Kit complains about branch naming

Spec Kit expects branches like `001-feature-name`. Use `speckit.specify`.

### Windows

Set `script_variant = "ps"` in `.sddkit/config.toml`, then `sync`.
