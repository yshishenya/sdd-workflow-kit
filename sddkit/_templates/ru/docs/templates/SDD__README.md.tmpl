# SDD в этом репозитории (Spec Kit + sdd-kit overlay)

> Tooling: `sdd-workflow-kit {{kit_version}}`

Этот репозиторий использует Spec-Driven Development (SDD) в гибридном режиме:

- **SDD ядро**: GitHub **Spec Kit** (markdown пайплайн `spec.md → plan.md → tasks.md → implement`)
- **Overlay**: `sdd-kit` (ставит/пинит инфраструктуру, делает drift-check managed файлов, добавляет опциональные скэффолды)

## TL;DR

### Разработчику (ежедневная работа)

1. Создать фичу: `$speckit-specify` (или скрипт `.specify/scripts/.../create-new-feature.*`)
2. План: `$speckit-plan`
3. Задачи: `$speckit-tasks`
4. Реализация: `$speckit-implement`
5. Перед PR: `python3 .tooling/sdd-workflow-kit/bin/sdd-kit check --project .`

### Админу (развертывание и обновления)

1. Подтянуть submodules: `git submodule update --init --recursive`
2. Синхронизировать managed файлы: `python3 .tooling/sdd-workflow-kit/bin/sdd-kit sync --project .`
3. Проверить дрейф: `python3 .tooling/sdd-workflow-kit/bin/sdd-kit check --project .`
4. Обновление toolchain: обновить submodule `.tooling/sdd-workflow-kit` на новый тег, затем `sync` + `check`

## Что это и зачем

Задача системы: сделать процесс разработки воспроизводимым.

- Spec Kit задает **единый SDD цикл** для новых фич.
- `sdd-kit` гарантирует, что инфраструктура Spec Kit (скрипты/шаблоны/промпты) **прибита к версии** и **проверяется на дрейф**.

Ключевая идея: мы не пытаемся «управлять всем репозиторием». Управляются только выбранные файлы и только в безопасном режиме.

## Как это работает (схема)

```mermaid
flowchart LR
  KIT["sdd-workflow-kit (git submodule)"] --> SYNC["sdd-kit sync"]
  SYNC --> SPECIFY[".specify/* (Spec Kit scripts + templates)"]
  SYNC --> PROMPTS[".codex/skills/speckit-command-name/SKILL.md"]
  SYNC --> FRAG[".sddkit/fragments/AGENTS.manual.md"]

  DEV["Developer / agent"] --> SPK["$speckit-specify, $speckit-plan, $speckit-tasks, $speckit-implement"]
  SPK --> SPECIFY
  SPK --> SPECS["specs/###-feature/spec.md, plan.md, tasks.md"]

  SPECIFY --> AG["AGENTS.md (Spec Kit updater)"]
  FRAG --> AG

  CHECK["sdd-kit check (CI/local gate)"] --> SPECIFY
  CHECK --> PROMPTS
  CHECK --> AG
```

## Где что лежит (структура)

```text
.sddkit/
  config.toml                  # настройки sdd-kit (ручные)
  fragments/
    AGENTS.manual.md           # overlay для MANUAL-блока в AGENTS.md (редактируй это)

.specify/                      # managed: Spec Kit templates/scripts (ставит sdd-kit)
  templates/                   # шаблоны: spec/plan/tasks/...
  scripts/
    bash/                      # sh-скрипты (mac/linux)
    powershell/                # ps-скрипты (windows)
  memory/
    constitution.md            # принципы/конституция (создается если нет; можно править руками)
  THIRD_PARTY_NOTICES.md       # managed: лицензии/атрибуция upstream Spec Kit

.codex/skills/                # managed: команды для Codex (speckit-*)
  speckit-specify/SKILL.md
  speckit-plan/SKILL.md
  speckit-tasks/SKILL.md
  speckit-implement/SKILL.md

specs/                         # NOT managed: артефакты фич (создает Spec Kit)
  001-feature-name/
    spec.md
    plan.md
    tasks.md
```

## Что кем управляется (ownership + drift-check)

- `.specify/templates/*`: управляет `sdd-kit` (копируется из pinned Spec Kit). `check` проверяет дрейф.
- `.specify/scripts/*`: управляет `sdd-kit`. `check` проверяет дрейф.
- `.codex/skills/speckit-command-name/SKILL.md`: управляет `sdd-kit` (генерируется из pinned Spec Kit). `check` проверяет дрейф.
- `.specify/memory/constitution.md`: **вы**. `sdd-kit` только создает файл, если его нет, и дальше не трогает.
- `specs/**`: создается/редактируется в рамках фичи. `sdd-kit` не проверяет содержимое.
- `AGENTS.md`: обновляется Spec Kit (`update-agent-context.*`). `sdd-kit` управляет только MANUAL-блоком.

### Важно про `AGENTS.md`

`AGENTS.md` — это файл контекста/правил для агента (Codex/и т.д.): где лежит код, какие команды запускать, какие ограничения у проекта.

В Spec Kit mode `AGENTS.md` не генерируется `sdd-kit` целиком. Его создаёт/обновляет Spec Kit скрипт `update-agent-context` (обычно на шаге `$speckit-plan`).

Если нужно создать/обновить `AGENTS.md` вручную:

```bash
bash .specify/scripts/bash/update-agent-context.sh codex
```

Локальные добавки редактируйте только через:

- `.sddkit/fragments/AGENTS.manual.md`

После правок фрагмента примените overlay:

```bash
python3 .tooling/sdd-workflow-kit/bin/sdd-kit sync --project .
```

`sync` патчит в `AGENTS.md` только блок:

```text
<!-- MANUAL ADDITIONS START -->
...
<!-- MANUAL ADDITIONS END -->
```

Так Spec Kit и overlay не конфликтуют.

Важно: не редактируйте `AGENTS.md` руками. В Spec Kit mode `sdd-kit check` проверяет, что MANUAL блок совпадает с `.sddkit/fragments/AGENTS.manual.md`.

По умолчанию в новых репозиториях `.sddkit/fragments/AGENTS.manual.md` уже создается с кросс-ссылками на:

- `docs/SDD/README.md` (основной workflow и команды)
- `meta/memory_bank/*` (если Memory Bank используется)
- правила PR/обновления задач (`workflows/code_review.md`, `guides/task_updates.md`)

Также по умолчанию туда добавлены краткие правила написания PR:

- целевая base-ветка
- формат заголовка Conventional Commits
- обязательные разделы описания PR
- ссылки на spec/work-item и обязательные pre-review проверки
- требование структуры Markdown для тела PR (заголовки/списки/чеклисты, а не plain text)
- запрет на видимые escape-переносы (`\n`, `\r\n`, `\t`) в тексте PR; используйте реальные переносы строк

Для старых репозиториев:

- если в fragment остался legacy-короткий текст, `sdd-kit sync` обновит его автоматически
- если fragment уже правили вручную, `sdd-kit` оставит ваш контент без перезаписи

## Как пользоваться (разработчику, по шагам)

### SDD цикл (схема)

```mermaid
flowchart TD
  START["Start"] --> SPECIFY["$speckit-specify"]
  SPECIFY --> SPEC["specs/###-.../spec.md"]

  SPEC --> AMBIG{"Ambiguity?"}
  AMBIG -->|yes| CLARIFY["$speckit-clarify"] --> SPEC

  AMBIG -->|no| PLAN["$speckit-plan"]
  PLAN --> PLAN_OUT["plan.md + artifacts + AGENTS.md"]
  PLAN_OUT --> TASKS["$speckit-tasks"]
  TASKS --> TASKS_MD["tasks.md"]

  TASKS_MD --> ANALYZE_OK{"Need analysis?"}
  ANALYZE_OK -->|yes| ANALYZE["$speckit-analyze (read-only)"] --> TASKS_MD
  ANALYZE_OK -->|no| IMPLEMENT["$speckit-implement"]
  IMPLEMENT --> CODE["Code + tests"]

  CODE --> DRIFT["sdd-kit check"]
  DRIFT --> PR["PR"]
```

### Как skills исполняются (runtime flow)

```mermaid
flowchart LR
  U["Пользователь запускает $speckit-..."] --> S["Загрузка .codex/skills/speckit-*/SKILL.md"]
  S --> C["Execution Contract"]
  C --> R["Сначала запуск .specify/scripts/..."]
  R --> O["Разбор вывода скрипта (часто JSON)"]
  O --> A["Обновление артефактов specs/NNN-..."]
  A --> X["Ответ и следующий шаг"]
```

Правила runtime:

- каждый `speckit-*` skill содержит `Execution Contract`
- если skill ссылается на `.specify/scripts/...`, сначала запускаются скрипты, потом анализ/правки
- исходники скриптов не читаются до первой попытки запуска
- если запуск скрипта упал, сначала возвращается ошибка, затем уже идет разбор скрипта

### Каталог команд Speckit

| Skill | Зачем | Что создает/обновляет | Когда запускать |
|---|---|---|---|
| `$speckit-specify` | Создать спецификацию новой фичи | `specs/NNN-.../spec.md`, ветка `NNN-...`, checklist | Старт фичи |
| `$speckit-clarify` | Убрать неоднозначности в требованиях | правки `spec.md` (clarifications) | До plan, если спек нечеткий |
| `$speckit-plan` | Сделать техплан и дизайн-артефакты | `plan.md`, `research.md`, `data-model.md`, `contracts/*`, `quickstart.md`, `AGENTS.md` | После `spec.md` |
| `$speckit-tasks` | Сгенерировать исполнимый декомпозированный план задач | `tasks.md` | После `plan.md` |
| `$speckit-implement` | Выполнить задачи с трассируемостью | Код/тесты + `[X]` в `tasks.md` | После `tasks.md` |
| `$speckit-analyze` | Проверить согласованность и покрытие | read-only отчёт в чате | Перед implement / перед PR |
| `$speckit-checklist` | Проверить качество требований | `specs/.../checklists/*.md` | После specify/clarify/plan |
| `$speckit-constitution` | Описать принципы проекта | `.specify/memory/constitution.md` | Инициализация/обновление правил |
| `$speckit-taskstoissues` | Выгрузить задачи в GitHub issues | GitHub issues | Когда нужен внешний трекинг |
| `$speckit-planreview` | Мульти-модельное advisory review | `specs/.../reviews/planreview.md` | После plan, до tasks/implement |

### Внешние зависимости команд

- базовый цикл (`specify/plan/tasks/implement`) работает через `.specify/scripts/*`
- для `$speckit-planreview` желательно установленный `opencode`
- для `$speckit-taskstoissues` нужен GitHub remote и рабочая GitHub MCP/auth интеграция

### 0) После `git clone`

Если в репозитории есть submodules:

```bash
git submodule update --init --recursive
```

### 1) `$speckit-specify` (создать `spec.md`)

Зачем: стартовать новую фичу и получить качественную спецификацию (что/зачем), без реализации.

Как запускать (через агента):

- `$speckit-specify <1-3 предложения описания фичи>`

Пример:

- `$speckit-specify Добавить экспорт отчета в PDF для админов`

Скрипт без агента (mac/linux):

```bash
bash .specify/scripts/bash/create-new-feature.sh "Короткое описание фичи"
```

Что делает и что появится:

- создаст и checkout'ит ветку вида `001-feature-name`
- создаст директорию `specs/001-feature-name/`
- создаст/заполнит `specs/001-feature-name/spec.md` по шаблону
- часто создаст `specs/001-feature-name/checklists/requirements.md` (чеклист качества спека)

### 1.1) (Опционально) `$speckit-clarify` (уточнить `spec.md`)

Зачем: убрать неоднозначности до планирования. Команда задаёт вопросы (до 5) и сразу записывает ответы в `spec.md`.

Как запускать:

- `$speckit-clarify`

Результат:

- обновит текущий `specs/001-.../spec.md` (добавит секцию Clarifications и внесёт точечные правки требований)

### 2) `$speckit-plan` (сделать `plan.md` и дизайн-артефакты)

Зачем: превратить `spec.md` в технический план, договориться об архитектуре и подготовить материалы для декомпозиции.

Требования:

- вы на feature-ветке `001-...` (обычно она создаётся `$speckit-specify`)
- `specs/001-.../spec.md` уже существует

Как запускать (через агента):

- `$speckit-plan` (можно добавить контекст: стек/платформа/ограничения)

Скрипты без агента:

```bash
bash .specify/scripts/bash/setup-plan.sh
bash .specify/scripts/bash/update-agent-context.sh codex
```

Что делает и что появится:

- создаст/обновит `specs/001-.../plan.md`
- обычно создаст дополнительные артефакты в `specs/001-.../` (набор зависит от проекта)
- обновит `AGENTS.md` через `update-agent-context` (overlay MANUAL блок сохранится)

Частые артефакты планирования (если применимо):

- `specs/001-.../research.md` (решение неизвестностей и выборов)
- `specs/001-.../data-model.md` (сущности/поля/связи/инварианты)
- `specs/001-.../contracts/*` (контракты API/интерфейсов)
- `specs/001-.../quickstart.md` (сквозные сценарии и проверки)

### 3) `$speckit-tasks` (сгенерировать `tasks.md`)

Зачем: получить исполнимый `tasks.md` (задачи, зависимости, пути к файлам) и выполнять его по пунктам.

Как запускать:

- `$speckit-tasks`

Что делает:

- читает `spec.md` и `plan.md` (и артефакты, если есть)
- генерирует `specs/001-.../tasks.md` по шаблону
- группирует задачи по user stories, добавляет ID (T001...), пометки параллельности `[P]`

Практика:

- если поменяли `plan.md` или требования, перегенерируйте `tasks.md` (это ожидаемо)
- для read-only проверки согласованности перед реализацией: `$speckit-analyze`

### 4) `$speckit-implement` (реализация по `tasks.md`)

Зачем: выполнить `tasks.md` по шагам, сохраняя трассируемость "spec -> plan -> tasks -> код".

Как запускать:

- `$speckit-implement`

Что делает:

- читает `tasks.md`/`plan.md` (и опциональные артефакты)
- выполняет задачи фазами и отмечает выполненные как `[X]` в `tasks.md`
- может остановиться и попросить подтверждение, если чеклисты в `specs/001-.../checklists/` не закрыты

Практика, чтобы не "уплывать":

- делайте задачи по одной (малые диффы)
- часто запускайте реальные проверки проекта (тесты/линт/сборка)
- если требования меняются, сначала обновите `spec.md/plan.md/tasks.md`, потом меняйте код

### Дополнительные команды `speckit-*` (когда нужно)

- `$speckit-analyze`: read-only анализ согласованности `spec.md`/`plan.md`/`tasks.md` (не меняет файлы).
- `$speckit-checklist <тема>`: создаёт чеклист качества требований в `specs/001-.../checklists/*.md` (это не тесты кода).
- `$speckit-planreview`: мульти-модельное ревью `spec.md/plan.md/tasks.md` (advisory-only) и запись отчёта в `specs/001-.../reviews/planreview.md`. Обычно запускают после `$speckit-plan` и до `$speckit-tasks/implement`. Требует установленный `opencode` (и опционально другие инструменты).
- `$speckit-constitution`: заполнение/обновление `.specify/memory/constitution.md` (принципы). В гибридном режиме не редактируйте `.specify/templates/*` и `.codex/skills/*` вручную: они managed.
- `$speckit-taskstoissues`: создаёт GitHub issues из задач (требуется GitHub remote и настроенный GitHub MCP в агенте).

### 5) Перед PR: проверить дрейф managed-файлов

```bash
python3 .tooling/sdd-workflow-kit/bin/sdd-kit check --project .
```

Если есть `DRIFT/MISSING`:

```bash
python3 .tooling/sdd-workflow-kit/bin/sdd-kit sync --project .
python3 .tooling/sdd-workflow-kit/bin/sdd-kit check --project .
```

## Админу: развертывание и поддержка

### Базовые команды

- `bootstrap`: создать `.sddkit/config.toml` (если нет) и сразу выполнить `sync`
- `sync`: привести managed-файлы к ожидаемому состоянию
- `check`: проверить, что проект не «уплыл» (удобно для CI)

### Safe mode (почему kit «не ломает» репозиторий)

По умолчанию включен `safe_mode = true`.

Это значит:

- kit пишет и обновляет только файлы, которые сам пометил как managed
- если файл уже существует, но он не managed, kit его **пропустит** (и покажет `UNMANAGED` в плане/проверке)

### CI: drift-check (GitHub Actions)

Критично для Spec Kit mode: checkout должен быть с `submodules: recursive`.

Обычно в CI запускают:

```bash
python3 .tooling/sdd-workflow-kit/bin/sdd-kit check --project . --config .sddkit/config.toml
```

### Обновление `sdd-workflow-kit` в этом репозитории

Рекомендованный процесс:

1. Обновить submodule `.tooling/sdd-workflow-kit` на новый тег.
2. `git submodule update --init --recursive`
3. `sync` и `check`
4. Закоммитить: обновление submodule + измененные managed-файлы.

### Синхронизация с upstream (если репозиторий — fork)

Если этот репозиторий является форком и вы тянете изменения из upstream, делайте это отдельным процессом, чтобы минимизировать конфликты.

1) Один раз добавить remote `upstream`:

```bash
git remote add upstream <UPSTREAM_GIT_URL>
git fetch upstream --tags
```

2) Делать синхронизацию на отдельной ветке:

```bash
git checkout <integration-branch>
git pull
git checkout -b chore/upstream-sync-YYYY-MM-DD
```

3) Интегрировать upstream (выберите один подход по политике команды):

- merge:

```bash
git merge upstream/<branch>
```

- rebase:

```bash
git rebase upstream/<branch>
```

4) Разрулить конфликты, прогнать проверки, зафиксировать результат.

Подсказка: если у вас включен Memory Bank, документируйте upstream-sync как work item и фиксируйте рискованные решения.

### Memory Bank (опционально)

Memory Bank можно включить параллельно со Spec Kit, это не конфликтует.

**Работает ли он \"автоматом\"?** Нет. Kit только устанавливает и обновляет managed-шаблоны при `sdd-kit sync`. Содержимое вы (или агент) поддерживаете вручную. Никаких фоновых процессов нет.

Где лежит (по умолчанию): `meta/memory_bank/`.

Как пользоваться (минимум):

1) Перед любой задачей откройте `meta/memory_bank/README.md` и пройдите Mandatory Reading Sequence.
2) Если добавили зависимость или поменяли архитектуру, обновите `meta/memory_bank/tech_stack.md` и/или соответствующий `patterns/*`.
3) Для трекинга работы:

- на feature-ветках не правьте `meta/memory_bank/current_tasks.md` (избегаем конфликтов)
- пишите обновления в `meta/memory_bank/branch_updates/*.md`
- на integration ветке вручную переносите обновления в `current_tasks.md` и удаляйте обработанные файлы

Хелпер: `meta/tools/merge_task_updates.sh` подскажет, какие `branch_updates/*.md` ждут обработки.

В `.sddkit/config.toml`:

```toml
[manage]
memory_bank = true
meta_tools = true
meta_sdd = true
```

Затем:

```bash
python3 .tooling/sdd-workflow-kit/bin/sdd-kit sync --project .
```

### Человекочитаемые спецификации

- В Spec Kit mode спеки и планы уже человекочитаемые: `specs/###-.../{spec,plan,tasks}.md` (Markdown).
- Если вы используете JSON SDD (опционально, `meta/sdd/specs/*.json`), то для людей можно генерировать Markdown рендером:

```bash
meta/tools/sdd render --help
```

Дальше рендерьте в файл (путь и флаги зависят от вашего `sdd` CLI). Рекомендация: хранить рендер рядом со спеком (например `meta/sdd/rendered/*.md`) или прикладывать как артефакт в CI.

## Troubleshooting

### `UNMANAGED ... (safe_mode)`

Значит файл уже существует и не помечен как managed.

Варианты:

- переименовать/удалить файл и снова `sync`
- отключить управление этим файлом в `[manage]`

Для старых глобальных unmanaged skills (`~/.codex/skills/speckit-*`) удалите эти каталоги и поставьте заново:

```bash
python3 .tooling/sdd-workflow-kit/bin/sdd-kit install-skills --project . --pack speckit --to global
```

### В `/skills` не видно `speckit-*`

Поставьте skills туда, откуда их читает текущая сессия Codex:

```bash
# project-local
python3 .tooling/sdd-workflow-kit/bin/sdd-kit install-skills --project . --pack speckit --to project

# global
python3 .tooling/sdd-workflow-kit/bin/sdd-kit install-skills --project . --pack speckit --to global
```

После установки откройте новый чат (или перезапустите Codex) и проверьте `/skills`.

### Spec Kit ругается на ветку

Spec Kit ожидает ветки вида `001-feature-name`. Создавайте фичи через `$speckit-specify`.

### Windows

Если репозиторий в Windows, используйте `script_variant = "ps"` в `.sddkit/config.toml` и синхронизируйте.
